---
title: Context
description: Track conversation history and state
---

## What is Context?

Context is a list of messages that tracks conversation history. Each message has a role (`user`, `assistant`, `tool`, `system`) and content.

```python
from a1 import get_context

ctx = get_context("main")

# Add messages
ctx.user("What is 2+2?")
ctx.assistant("4")

# Access messages
for msg in ctx:
    print(f"{msg.role}: {msg.content}")
```

## Messages

Four message types:

```python
# User input
ctx.user("Hello")

# Assistant response
ctx.assistant("Hi there")

# Tool calls and results
ctx.assistant("", tool_calls=[...])
ctx.tool(content="result", name="tool_name", tool_call_id="id")

# System prompts (rare)
ctx.system("You are helpful")
```

## When Messages Are Added

**During JIT execution:**
- User input added at start
- Assistant output added at end
- Tool calls added during execution

**During AOT compilation:**
- Nothing added to main context
- Compilation attempts tracked in separate contexts

**During compiled tool execution:**
- Same as regular tool execution
- Nothing added to main context

## Runtime

Runtime manages all contexts for a session:

```python
from a1 import Runtime

runtime = Runtime()

with runtime:
    ctx = get_context("main")
    ctx.user("Hello")
```

Runtime handles:
- Context lifecycle (creation, cleanup)
- Named contexts (`main`, `attempt_a`, etc.)
- Context isolation between sessions

## Persistence

Save and load contexts:

```python
from a1 import Context

# Auto-save on every change
ctx = Context.from_file("chat.json", keep_updated=True)
ctx.user("Hello")  # Automatically saved

# Load later
ctx = Context.from_file("chat.json")

# Or save entire runtime
runtime = Runtime.from_file("session.json", keep_updated=True)
```
